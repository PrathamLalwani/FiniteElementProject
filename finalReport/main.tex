
\documentclass{report}

\input{preamble}
\input{macros}
\input{letterfonts}

\usepackage{booktabs} % For nicer looking tables
% \usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
% Page Geometry
\geometry{
    left=1in,
    right=1in,
    top=1in,
    bottom=1in
}

\title{\Huge{Finite Element Method:}\\Poisson Equation}
\author{\huge{Pratham Lalwani}}
\date{}

\begin{document}

\maketitle
\newpage% or \cleardoublepage
% \pdfbookmark[<level>]{<title>}{<dest>}
\pdfbookmark[section]{\contentsname}{toc}
\tableofcontents
\pagebreak

\chapter{Introduction}
Solving PDEs is one of the most ubiquitous and challenging problems in Mathematics. Some PDEs have a closed form analytic solution under some circumstances but most are unsolvable and thus are solved by numerical methods. There are various methods to solve PDEs but by far the most flexible one of them is the Finite Element Method.

The Finite Element method is to solve various forms of PDEs  .. Include Examples . It is used widely in industry due to it's flexibility and reliability.

This report will outline the basics of finite element method and what are it's pros and cons.
\chapter{Theory}
\section{Approximating functions}
Given data points $\{(x_i,y_i)\}_{i=1}^{N}$, an interpolant is a function $f$ such that $f(x_{i}) = y_{i}$. The process of finding such an $f$ is called interpolation. There are many ways to perform interpolation, including polynomial interpolation, Fourier Transform, and Spline interpolation. 

One of the easiest interpolation techniques, which is fundamental to FEM, is Piecewise Linear Interpolation. This method divides the domain into $n$ intervals (elements) and fits a linear function between the endpoints (nodes). 

% 

There are two primary ways to achieve a linear approximation in this context: Piecewise linear interpolation and the $L^2$-Projection method.

\subsection{Linear Interpolation}
Let $\Omega = [a, b]$ be partitioned into nodes $x_0, x_1, \dots, x_N$. We define basis functions $\phi_i(x)$ (often called ``hat functions'') such that:
\begin{equation}
    \phi_i(x_j) = \delta_{ij} = \begin{cases} 1 & \text{if } i=j \\ 0 & \text{if } i \neq j \end{cases}
\end{equation}

% 

The linear interpolant $\pi_h u$ of a continuous function $u$ is given by:
\begin{equation}
    \pi_h u(x) = \sum_{i=0}^N u(x_i)\phi_i(x)
\end{equation}
This approximation is exact at the nodes but introduces error inside the intervals, which depends on the mesh size $h$.

\subsection{\texorpdfstring{$L^2$}{L2}-Projection}
While interpolation forces exact values at nodes, $L^2$-projection seeks the ``best fit'' approximation in an integral sense. We seek a function $u_h$ in our finite element space $V_h$ that minimizes the $L^2$ error:
\begin{equation}
    \min_{v_h \in V_h} \| u - v_h \|_{L^2(\Omega)}^2
\end{equation}
Practically, this leads to a system of equations involving the mass matrix, ensuring the error is orthogonal to the approximation space.

\section{The Finite Element Method}

\subsection{Weak Form of a PDE}
The classical (strong) form of a PDE requires the solution to be twice differentiable. FEM relies on the \textbf{Weak Form}, which relaxes these requirements.

Consider the 1D Poisson problem:
\begin{equation}
    -u''(x) = f(x) \quad \text{on } (0,1), \quad u(0)=u(1)=0
\end{equation}
To derive the weak form, we multiply by a test function $v$ and integrate by parts. The weak formulation is: Find $u \in V$ such that for all $v \in V$:
\begin{equation}
    \int_0^1 u'(x)v'(x) \, dx = \int_0^1 f(x)v(x) \, dx
\end{equation}
This bilinear form is usually denoted $a(u,v) = L(v)$.

\subsection{Mass and Stiffness Matrices}
To solve this numerically, we substitute $u \approx u_h = \sum_{j} \xi_j \phi_j$ and choose test functions $v = \phi_i$. This yields a linear system $A\xi = b$.

\begin{itemize}
    \item \textbf{The Stiffness Matrix ($A$ or $K$):} Represents the discrete Laplacian.
          \begin{equation}
              A_{ij} = a(\phi_j, \phi_i) = \int_\Omega \phi_j'(x) \phi_i'(x) \, dx
          \end{equation}

    \item \textbf{The Mass Matrix ($M$):} Represents the $L^2$ inner product.
          \begin{equation}
              M_{ij} = (\phi_j, \phi_i) = \int_\Omega \phi_j(x) \phi_i(x) \, dx
          \end{equation}
\end{itemize}

\section{Error Analysis of FEM for Poisson Problem}
A fundamental result in FEM theory is \textbf{Céa's Lemma}. For piecewise linear elements on a mesh with size $h$, the error estimates are:
\begin{enumerate}
    \item \textbf{Energy Norm ($H^1$):} $\| u - u_h \|_{H^1} \leq C h \| u \|_{H^2}$ (Linear convergence).
    \item \textbf{$L^2$ Norm:} $\| u - u_h \|_{L^2} \leq C h^2 \| u \|_{H^2}$ (Quadratic convergence).
\end{enumerate}
This implies that halving the mesh size reduces the $L^2$ error by a factor of 4.

\chapter{Implementation}

\subsection{Computation of Mass and Stiffness Matrices}
In practice, we iterate over elements rather than nodes. For a uniform 1D mesh with element size $h$:

The local stiffness matrix for a single element is:
\begin{equation}
    K_{local} = \frac{1}{h} \begin{bmatrix} 1 & -1 \\ -1 & 1 \end{bmatrix}
\end{equation}

The local mass matrix for a single element is:
\begin{equation}
    M_{local} = \frac{h}{6} \begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix}
\end{equation}
These local matrices are then ``assembled'' into the global system matrices based on the global node indices.

\subsection{Pseudocode of Finite Element for Poisson Equation}
The general procedure for solving the Poisson equation in 1D or 2D is similar, differing mostly in mesh generation and basis function definitions.

\begin{algorithm}[H]
\caption{FEM for Poisson Equation ($-\Delta u = f$)}
\KwIn{Mesh $\mathcal{T}$, Load function $f$}
\KwOut{Solution vector $\mathbf{u}$}
Initialize Global Stiffness Matrix $K = 0$, Load Vector $b = 0$\;
\For{each element $T \in \mathcal{T}$}{
    Compute local stiffness matrix $K_{loc}$\;
    Compute local load vector $b_{loc}$ using quadrature\;
    Assemble $K_{loc} \to K$ and $b_{loc} \to b$ based on global indices\;
}
\textbf{Apply Boundary Conditions:}\\
\For{each boundary node $i$}{
    Modify row $i$ of $K$ and $b_i$ to enforce Dirichlet BCs\;
}
Solve linear system $K \mathbf{u} = \mathbf{b}$\;
\end{algorithm}

\subsection{Pseudocode for Adaptive Finite Element}
Adaptive FEM (AFEM) improves accuracy by refining the mesh only where the error is high, rather than uniformly.

\begin{algorithm}[H]
\caption{Adaptive Finite Element Method (SOLVE-ESTIMATE-MARK-REFINE)}
\KwIn{Initial coarse mesh $\mathcal{T}_0$, Tolerance $\epsilon$}
\KwOut{Refined Solution $u_k$}
$k \leftarrow 0$\;
\While{Estimated Error $> \epsilon$}{
    \textbf{SOLVE:} Compute discrete solution $u_k$ on $\mathcal{T}_k$\;
    \textbf{ESTIMATE:} Compute error indicator $\eta_T(u_k)$ for each element $T$\;
    \textbf{MARK:} Select set of elements $\mathcal{M} \subset \mathcal{T}_k$ with largest $\eta_T$ (e.g., Dörfler marking)\;
    \textbf{REFINE:} Bisect elements in $\mathcal{M}$ to generate $\mathcal{T}_{k+1}$\;
    $k \leftarrow k+1$\;
}
\end{algorithm}

\chapter{Numerical Results}

\subsection{Convergence of Interpolants}
To verify the theory, we test the interpolation error of a known function $u(x) = \sin(\pi x)$. Plotting the error against mesh size $h$ on a logarithmic scale reveals:
\begin{itemize}
    \item Slope $\approx 2$ for the $L^2$ norm.
    \item Slope $\approx 1$ for the $H^1$ semi-norm.
\end{itemize}

\subsection{Example Problem: Poisson Equation on Different Domains}
We examine the behavior of FEM on the Poisson equation $-\Delta u = 1$ with Dirichlet boundary conditions on three domains:

\subsubsection{Unit Square}
On a unit square, the mesh is regular, and the solution is smooth. We observe optimal convergence rates ($O(h^2)$ in $L^2$ norm). The stiffness matrix is highly structured.

\subsubsection{Unit Circle}
% 

For a circular domain, the boundary is approximated by a polygon. This geometric approximation introduces a "variational crime." As the mesh is refined, the polygonal boundary approaches the true circle, but the error near the boundary can dominate if not handled correctly.

\subsubsection{L-Shaped Domain (Re-entrant Corner)}
% 

The L-shaped domain contains a re-entrant corner (a $270^\circ$ interior angle). The exact solution typically has a singularity at this corner, where the gradient goes to infinity ($\nabla u \sim r^{-1/3}$). Because $u$ is not in $H^2$, the standard theoretical convergence rates fail. Uniform refinement yields suboptimal convergence ($< O(h)$). This is a prime candidate for the \textbf{Adaptive FEM} described earlier, which heavily refines the mesh near the corner to recover optimal rates.

\subsection{Convergence Plots}
\begin{table}[h!]
    \centering
    \begin{tabular}{ccc}
        \toprule
        \textbf{Mesh size ($h$)} & \textbf{$L^2$ Error} & \textbf{Order ($p$)} \\
        \midrule
        0.1                      & 1.25e-3              & --                   \\
        0.05                     & 3.12e-4              & 2.00                 \\
        0.025                    & 7.80e-5              & 2.00                 \\
        \bottomrule
    \end{tabular}
    \caption{Convergence rates for the Poisson problem on a square using linear elements.}
    \label{tab:convergence}
\end{table}

As shown in Table \ref{tab:convergence}, the numerical order of convergence matches the theoretical prediction of 2 for smooth domains. However, for the L-shape domain, the order drops to approximately $0.66$ without adaptivity.

\subsection{Comparison with Finite Difference}
% 

\begin{itemize}
    \item \textbf{Geometry:} Finite Difference (FD) relies on structured grids (squares/rectangles), making it difficult to implement on curved domains (like the circle). FEM handles unstructured triangular/tetrahedral meshes naturally.
    \item \textbf{Boundary Conditions:} Implementing Neumann (derivative) boundary conditions is more natural in FEM (via the weak form) than in FD.
    \item \textbf{Simplicity:} FD is generally easier to implement for simple box domains, whereas FEM requires complex data structures (mesh connectivity, assembly).
\end{itemize}

\chapter{Conclusion}

\section{Pros and Cons of using Finite Element}
\textbf{Pros:}
\begin{itemize}
    \item \textbf{Geometric Flexibility:} Can model complex, irregular shapes standard in engineering (cars, turbines, bones).
    \item \textbf{Mathematical Rigor:} Strong theoretical foundations for error analysis ($L^2$ and $H^1$ error bounds).
    \item \textbf{Material Heterogeneity:} Easily handles different materials in different elements.
    \item \textbf{Boundary Conditions:} Natural handling of Neumann and Robin boundary conditions.
\end{itemize}

\textbf{Cons:}
\begin{itemize}
    \item \textbf{Complexity:} Implementation is significantly more involved than Finite Difference, requiring mesh generation and matrix assembly.
    \item \textbf{Computational Cost:} Assembly of the global matrix can be expensive, and the resulting systems are often unstructured, requiring sophisticated solvers.
\end{itemize}

\end{document}
